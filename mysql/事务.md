#事务(Transaction)
作为一个基本的工作单元执行一系列SQL语句的操作，要么完全执行，要么完全不执行
## 事务的四大特性（ACID）
    原子性：一个事务必须被视为不可分割的最小工作单元，整个事务的所有操作要么全部提交成功，要么全部失败回滚
          对于一个事务来说不可能只执行其中的一部分
    一致性：数据库总是从一个一致性的状态转到另一个一致性的状态
    隔离性：一个事务所做的修改在提交前对其他事务是不可见的
    持久性：一旦事务提交，它所做的修改会永久保存到数据库
## 事务的使用
需要注意：1、表的引擎类型必须是innodb类型才可以使用事务，这是目前mysql表的默认引擎
        2、开启事务，执行变更的sql语句，数据的变更会维护到缓存中，不会更新到物理表中
           会不会更新物理表，取决于事务执行成功后commit,失败rollback
        
    1、开启事务
    开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中
    begin; 或者 start transaction;
    2、提交事务
    将缓存中的数据变更维护到物理表中
    commit;
    3、回滚事务
    放弃缓存中变更的数据 表示事务执行失败 应该回到开始事务前的状态
    rollback;
## 什么时候会使用事务？
    1、show variables like 'autocommit';默认是on
    我们在数据库中，或者程序中执行一条update的sql语句，默认事务会自动提交
    2、我们手动去开启
        begin;
        update table set
        commit;
## 事务并发会带来哪些问题？
    脏读：在一个事务里，其他事务这个时候修改了数据并且没有提交，导致这个事务前后读取的数据不一致的问题
         即读到了其他事务为提交的数据
    不可重复度：一个事务读取到其他事务已经提交的数据导致前后读取的数据不一致的情况
    幻读：一个事务读取了其他事务插入的数据，导致前后两次读取的数据不一致的情况
    它们都是数据库的读一致性的问题，都是在一个事务
    里面前后两次读取出现了不一致的情况。这些问题都是与事务的隔离性有关

## 怎样解决数据库并发问题？
    SQL92定义了四个事务的隔离级别：
    未提交读（Read Uncommitted):一个事务可以读取到其他事务未提交的数据，没有解决任何问题
    已提交读（Read Committed）: 一个事务只能读取其他事务已经提交的数据，解决脏读的问题，但是没有解决不可重复读的问题
    可重复度（Read Repeatable):解决了不可重复读的问题，也就是在一个事务中，多次读取其他事务提交的数据结果相同
                             但是他没有解决幻读的问题
    串行化（Serializable）:在这个隔离级别中，所有的事务都是串行执行，也就是对数据的操作需要排队，他解决了所有的问题，
                         但是事务的并发度太低
## MySQL InnoDB 对隔离级别的支持
    InnoDB 支持的四个隔离级别和SQL92 定义的基本一致，隔离级别越高，事务的并
    发度就越低。唯一的区别就在于，InnoDB 在RR 的级别就解决了幻读的问题。这个也是
    InnoDB 默认使用RR 作为事务隔离级别的原因，既保证了数据的一致性，又支持较高的
    并发度。
## MySQL InnoDB实现方案
###LBCC(基于锁的并发控制)
    我既然要保证前后两次读取数据一致，那么我读取数据的时候，锁定我要操作的数据，不允许其他的事务修改就行了
    存在问题：如果仅仅是基于锁来实现事务隔离，一个事物在读取的时候不允许其他事务进行修改，那就意味这不支持并发的读写操作，
            会极大的影响操作数据苦的效率
            

###MVCC(多版本的并发控制)  
    我们要实现读一致性，我们在修改数据前给他建一个备份或者快照，后面在来读取这个快照就可以了
    MVCC的核心思想：我们可以查询到在我这个事务开启之前的原始数据，即使他在之后的其他事务修改或者删除了，在我这个事务之后新增的
                  数据，也是查不到的
    问题来了：这个快照什么时候创建？再次读取数据的时候怎么保证读取的是快照的数据而不是最新的数据呢？  
    InnoDB 为每行记录都实现了两个隐藏字段：DB_TRX_ID（创建版本号），DB_ROLL_PTR（删除版本号）
    MVCC的查找规则：只能查找创建版本号小于或等于当前事物id的数据，和删除版本号大于当前事务版本号的数据
## MySQL InnoDB 锁的基本类型
    我们把两个行级别的锁和两个表级别的锁称为锁的基本模式
    而Record Locks（记录锁）、Gap Locks（间隙锁）、Next-Key Locks（临键锁）称为锁的算法
    