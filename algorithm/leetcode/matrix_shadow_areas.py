# coding=UTF-8
#  在一个坐标系上有两个矩阵，坐标分别是： 矩阵1：左上角（lx1, ly1)，右下角（rx1, ry1） 矩阵2：左上角（lx2, ly2)，右下角（rx2, ry2） 求两个矩阵重叠的面积
# 请自己完成测试
# 例1：第一个矩阵(1, 7), (10, 3)，第二个矩阵(2, 6), (5, 0)，结果为9
# 例2：第一个矩阵(-3, 0), (0, -3) 第二个矩阵(2, 5), (4, 3)，结果为0
# 例3：第一个矩阵(1, 5), (6, 2)，第二个矩阵(4, 4), (7, 1)，结果为4

def shadow_area(a, b):
    """
    把第一个矩阵放到一个列表中[(1, 7), (10, 3)],第二个矩阵放到列表中[(2, 6), (5, 0)]
    取出x轴的最小值，和y轴的最小值也就可以计算出阴影部分的面积
    """
    # 1、先判断两个矩阵是否有重叠，第一个矩阵x轴的最大值，y轴的最大值都小于第二个矩阵的对应的最小值
    if a[1][0] < b[0][0] and a[0][1] < b[0][1]:
        return 0
    elif b[1][0] < a[0][0] and b[0][1] < a[0][1]:
        return 0
    else:
        # 2、有重叠，即有阴影面积，需要取出阴影的左上角和右下角的坐标，就可以计算出阴影的面积
        # 取出阴影部分左上角的坐标

        lx = max([a[0][0], b[0][0]])
        ly = min([a[0][1], b[0][1]])
        # 取出阴影部分右下角的坐标
        rx = min([a[1][0], b[1][0]])
        ry = max([a[1][1], b[1][1]])
        sx = rx - lx
        sy = ly - ry
        return sx * sy


shadow_area1 = shadow_area([(1, 7), (10, 3)], [(2, 6), (5, 0)])
shadow_area2 = shadow_area([(-3, 0), (0, -3)], [(2, 5), (4, 3)])
shadow_area3 = shadow_area([(1, 5), (6, 2)], [(4, 4), (7, 1)])
print(shadow_area1)
print(shadow_area2)
print(shadow_area3)
